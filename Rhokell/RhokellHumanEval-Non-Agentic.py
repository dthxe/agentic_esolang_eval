# -*- coding: utf-8 -*-
"""Evalrhokell.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TfEiitSuCgmNZOyMA2YmyvIjkE8jO9JU
"""

!curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
import os
os.environ["PATH"] += ":/root/.cargo/bin"
!cargo install --git https://github.com/pro465/rhokell

rhokell_doc = r"""

rhokell
Paradigm(s)	Declarative, Functional
Designed by	User:Pro465
Appeared in	2023
Memory system	Tree based
Computational class	Turing complete
Major implementations	Rust
Influenced by	Haskell
File extension(s)	.rhkx
rhokell created by User:Pro465 is a mixture of rho calculus + haskell. it consists of a list of rules separated by ;, each consisting of two untyped expressions separated by =.

it reduces greedily/applicative-order-ly. that means arguments are reduced before their functions. more specifically, for any expression (a b),

first a is reduced,
then b,
and finally (a b).
it also always applies the first match that is found, unlike haskell (which just throws an error).

example of peano addition:

(add (z) y) = (y);
(add (s x) y) = (s (add x y));
(yes I know it looks like lisp, but that's purely coincidental)

note that the pattern is required to not be just a variable, so we cannot write:

x = (s x);

Contents
1	Explanation
1.1	normal vs REPL vs RD mode
1.2	Difference between variable and function names
1.3	Data types
1.4	I/O
1.4.1	byte "data type"
1.4.2	Functions for I/O
2	Examples
2.1	text to cons list
2.2	Peano multiplication and exponentiation
2.3	Hello, world!
2.4	Truth Machine
2.5	Cat
2.6	Reverse cat
2.7	Kolakoski sequence
2.8	Quine
3	See also
4	Links
Explanation
normal vs REPL vs RD mode
In normal mode, the interpreter calls the (main) function if it is defined, and runs it.
In REPL mode, the interpreter evaluates an expression given by the user, and prints the resulting expression in a loop.
In RD (ResultDisplay) mode, the interpreter calls the (main) function if it is defined, and runs it. Then it prints the resulting expression.

The normal mode is required, while the REPL and RD modes are optional for any implementation.

Difference between variable and function names
first off, (a b c) is syntax sugar for (((a) b) c). secondly, an identifier is a group of contiguous alphanumeric unicode characters. OK, now we can talk.

the difference between a variable (that matches anything) and a function (that only matches itself) in the pattern side is easy:

If an expression is of the form (f) where f is an identifier, then f is a function name.
If, however, it is of the form (f v), where v is an identifier, then v is a variable name.
in other words, an identifier in argument position is a variable. otherwise, it's a function name.

However, in the replacement side (the RHS of the =), things are a bit more complex: what might seem to be "function names" can turn out to be actually variables when their name is bound to a variable in the pattern (the LHS). for example:

(if e1 e2 arg (F)) = (e2 arg);
here, even though e2 appears to be a function name, it is actually a variable due to being bound by the e2 in the pattern. If, however, e2 did not appear in the pattern, it would really be a function name much like if or F.

Data types
there are no data types. Instead data types are emulated by functions with no defined rules, like s x, or (cons a list).

I/O
byte "data type"
a (byte (a) (b)) represents a byte with its upper and lower half being a and b respectively. a and b are in hexadecimal. so it means 0x{a}{b} in other programming languages. For example: (byte (6) (F)) means 0x6F, which corresponds to the character 'o' in ascii.

Functions for I/O
two function names are special for I/O operations: input and output

(input) - reduces to the next byte given in standard input in the form of (byte (a) (b)). If there are no more bytes left, reduces to (EOF).
((output) (byte (a) (b))) - reduces to (output), while printing the byte to standard output. if the argument given is not of the form for byte given above, it does not print anything.
Examples
text to cons list
open in REPL mode, type (tr), press enter, then give input.

(tr) = (transform (input));
(transform (byte (0) (A))) = (cons (byte (0) (A)) (nil));
(transform x) = (cons x (transform (input)));
Peano multiplication and exponentiation
works only in repl mode

(add (z) y) = (y);
(add (s x) y) = (s (add x y));
(mul (z) y) = (z);
(mul (s x) y) = (add y (mul x y));
(exp x (z)) = (s (z));
(exp x (s y)) = (mul x (exp x y));
Hello, world!
Made with the help of the "text to cons list" program above.

(main) = (print
             (cons (byte (4) (8)) # "H"
             (cons (byte (6) (5)) # "e"
             (cons (byte (6) (C)) # "l"
             (cons (byte (6) (C)) # "l"
             (cons (byte (6) (F)) # "o"
             (cons (byte (2) (C)) # ","
             (cons (byte (2) (0)) # " "
             (cons (byte (7) (7)) # "w"
             (cons (byte (6) (F)) # "o"
             (cons (byte (7) (2)) # "r"
             (cons (byte (6) (C)) # "l"
             (cons (byte (6) (4)) # "d"
             (cons (byte (2) (1)) # "!"
             (cons (byte (0) (A)) # "\n"
                   (nil))))))))))))))));
(print (cons x y)) = (then (output x) (print y));
(then a b) = b;
Truth Machine
(main) = (a (input) (output));
(a (byte (3) (0)) o) = (o (byte (3) (0)));
(a x o) = (a x (o x));
Cat
(main) = (cat (input) (output));
(cat (EOF) o) = (do_nothing);
(cat x o) = (cat (input) (o x));
Reverse cat
(main) = (print (reverse (collect (input))));

(collect (EOF)) = (nil);
(collect b) = (cons b (collect (input)));

(print (cons x y)) = (then (output x) (print y));

(reverse (nil)) =  (nil);
(reverse (cons x y)) = (append (reverse y) (cons x (nil)));

(append (nil) x) = x;
(append (cons x y) z) = (cons x (append y z));

(then a b) = b;
Kolakoski sequence
uses O(log n) space and O(n) time to print to nth term.

# this implements a minor variant of the algorithm given here:
# https://www.emis.de/journals/JIS/VOL15/Nilsson/nilsson5.pdf
#
# specifically, instead of initializing P[k] with "22" before
# carrying out the increment logic,
# it simply returns after "setting" it to "2".

# first print "1, 2, "
(main) = (kolakoski (then (print (1) (2)) (nil)));

(kolakoski x) = (kolakoski (print_next (inc x)));

(inc (nil)) = (cons (2) (nil));
(inc (cons (t a) b)) = (cons a b);
(inc (cons a b)) = (repeat (inc b) (next a));

(repeat (cons a b) sym) = (cons (times (get a) sym) (cons a b));

(times (1) s) = s;
(times (2) s) = (t s);

(get (t b)) = b;
(get b) = b;

(next (1)) = (2);
(next (2)) = (1);

(print_next (cons a b)) = (then (print (get a)) (cons a b));
(print a) = (then (o (3) a (2) (C) (2) (0)) (print));
(o a b) = (then (output (byte a b)) (o));

(then a b) = b;
Quine
Warning: looong code wall incoming

(data) = (c (3) (B) (c (0) (A) (c (2) (8) (c (6) (D) (c (6) (1) (c (6) (9) (c (6) (E) (c (2) (9)
(c (2) (0) (c (3) (D) (c (2) (0) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (8) (c (6) (4) (c (6) (F) (c (2) (0) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (2) (c (6) (5)
(c (6) (6) (c (6) (F) (c (7) (2) (c (6) (5) (c (5) (F) (c (6) (4) (c (6) (1) (c (7) (4)
(c (6) (1) (c (2) (9) (c (2) (0) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9)
(c (6) (E) (c (7) (4) (c (5) (F) (c (6) (4) (c (6) (1) (c (7) (4) (c (6) (1) (c (2) (0)
(c (2) (8) (c (6) (4) (c (6) (1) (c (7) (4) (c (6) (1) (c (2) (9) (c (2) (0) (c (2) (8)
(c (7) (A) (c (2) (9) (c (2) (0) (c (2) (8) (c (7) (A) (c (2) (9) (c (2) (9) (c (2) (0)
(c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F)
(c (6) (3) (c (6) (F) (c (6) (4) (c (6) (5) (c (2) (0) (c (2) (8) (c (6) (4) (c (6) (1)
(c (7) (4) (c (6) (1) (c (2) (9) (c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (9) (c (3) (B) (c (0) (A) (c (0) (A) (c (0) (A) (c (2) (8) (c (6) (2)
(c (6) (5) (c (6) (6) (c (6) (F) (c (7) (2) (c (6) (5) (c (5) (F) (c (6) (4) (c (6) (1)
(c (7) (4) (c (6) (1) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (0) (A) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (6) (C)
(c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (0) (c (2) (8)
(c (3) (6) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9) (c (2) (0) (c (2) (8)
(c (3) (6) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (1) (c (2) (9) (c (2) (0) (c (2) (8)
(c (3) (7) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9) (c (2) (0) (c (2) (8)
(c (3) (6) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (1) (c (2) (9) (c (2) (0) (c (2) (8)
(c (7) (2) (c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (0)
(c (2) (8) (c (7) (3) (c (7) (0) (c (6) (1) (c (6) (3) (c (6) (5) (c (2) (9) (c (2) (0)
(c (2) (8) (c (3) (3) (c (2) (9) (c (2) (0) (c (2) (8) (c (4) (4) (c (2) (9) (c (2) (0)
(c (2) (8) (c (7) (3) (c (7) (0) (c (6) (1) (c (6) (3) (c (6) (5) (c (2) (9) (c (2) (9)
(c (3) (B) (c (0) (A) (c (0) (A) (c (0) (A) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9)
(c (6) (E) (c (7) (4) (c (5) (F) (c (6) (4) (c (6) (1) (c (7) (4) (c (6) (1) (c (2) (0)
(c (7) (8) (c (2) (0) (c (2) (8) (c (7) (3) (c (2) (0) (c (2) (8) (c (7) (3) (c (2) (0)
(c (2) (8) (c (7) (3) (c (2) (0) (c (2) (8) (c (7) (3) (c (2) (0) (c (2) (8) (c (7) (3)
(c (2) (0) (c (2) (8) (c (7) (3) (c (2) (0) (c (2) (8) (c (7) (3) (c (2) (0) (c (2) (8)
(c (7) (3) (c (2) (0) (c (2) (8) (c (7) (A) (c (2) (9) (c (2) (9) (c (2) (9) (c (2) (9)
(c (2) (9) (c (2) (9) (c (2) (9) (c (2) (9) (c (2) (9) (c (2) (9) (c (2) (0) (c (3) (D)
(c (2) (0) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (4)
(c (6) (F) (c (2) (0) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (3) (0)
(c (2) (9) (c (2) (0) (c (2) (8) (c (4) (1) (c (2) (9) (c (2) (9) (c (0) (A) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8)
(c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F) (c (6) (4) (c (6) (1)
(c (7) (4) (c (6) (1) (c (2) (0) (c (7) (8) (c (2) (0) (c (2) (8) (c (7) (A) (c (2) (9)
(c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (3) (0) (c (2) (9)
(c (2) (0) (c (2) (8) (c (4) (1) (c (2) (9) (c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (9) (c (3) (B) (c (0) (A) (c (2) (8) (c (7) (0) (c (7) (2)
(c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F) (c (6) (4) (c (6) (1) (c (7) (4) (c (6) (1)
(c (2) (0) (c (2) (8) (c (6) (3) (c (2) (0) (c (7) (7) (c (2) (0) (c (7) (8) (c (2) (0)
(c (7) (9) (c (2) (9) (c (2) (0) (c (7) (A) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0)
(c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (4) (c (6) (F)
(c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (6) (C) (c (7) (0) (c (6) (1)
(c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (6) (c (2) (9)
(c (2) (0) (c (2) (8) (c (3) (3) (c (2) (9) (c (2) (0) (c (2) (8) (c (7) (3) (c (7) (0)
(c (6) (1) (c (6) (3) (c (6) (5) (c (2) (9) (c (2) (0) (c (2) (8) (c (6) (C) (c (7) (0)
(c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (9) (c (0) (A) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8)
(c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F) (c (6) (8) (c (6) (5)
(c (7) (8) (c (2) (0) (c (7) (7) (c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0)
(c (2) (8) (c (7) (2) (c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9)
(c (2) (0) (c (2) (8) (c (7) (3) (c (7) (0) (c (6) (1) (c (6) (3) (c (6) (5) (c (2) (9)
(c (2) (0) (c (2) (8) (c (6) (C) (c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E)
(c (2) (9) (c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E)
(c (7) (4) (c (5) (F) (c (6) (8) (c (6) (5) (c (7) (8) (c (2) (0) (c (7) (8) (c (2) (9)
(c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (7) (2) (c (7) (0) (c (6) (1)
(c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (0) (c (2) (8) (c (7) (3) (c (7) (0)
(c (6) (1) (c (6) (3) (c (6) (5) (c (2) (9) (c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (7) (0)
(c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F) (c (6) (4) (c (6) (1) (c (7) (4)
(c (6) (1) (c (2) (0) (c (7) (9) (c (2) (0) (c (2) (8) (c (7) (3) (c (2) (0) (c (7) (A)
(c (2) (9) (c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (7) (2)
(c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (9) (c (0) (A)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (9) (c (3) (B) (c (0) (A) (c (2) (8)
(c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F) (c (6) (4) (c (6) (1)
(c (7) (4) (c (6) (1) (c (2) (0) (c (2) (8) (c (6) (E) (c (2) (9) (c (2) (9) (c (2) (0)
(c (3) (D) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (6) (C) (c (7) (0)
(c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (6)
(c (2) (9) (c (2) (0) (c (2) (8) (c (4) (5) (c (2) (9) (c (2) (0) (c (2) (8) (c (7) (2)
(c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (9) (c (3) (B)
(c (0) (A) (c (0) (A) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4)
(c (5) (F) (c (6) (3) (c (6) (F) (c (6) (4) (c (6) (5) (c (2) (0) (c (2) (8) (c (6) (3)
(c (2) (0) (c (7) (8) (c (2) (0) (c (7) (9) (c (2) (0) (c (7) (A) (c (2) (9) (c (2) (9)
(c (2) (0) (c (3) (D) (c (2) (0) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (8) (c (6) (4) (c (6) (F) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (7) (8)
(c (2) (0) (c (7) (9) (c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9)
(c (6) (E) (c (7) (4) (c (5) (F) (c (6) (3) (c (6) (F) (c (6) (4) (c (6) (5) (c (2) (0)
(c (7) (A) (c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (9)
(c (3) (B) (c (0) (A) (c (0) (A) (c (2) (8) (c (7) (3) (c (7) (0) (c (6) (1) (c (6) (3)
(c (6) (5) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (2) (c (2) (0)
(c (2) (8) (c (3) (2) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (0) (c (2) (9) (c (2) (9)
(c (3) (B) (c (0) (A) (c (2) (8) (c (6) (C) (c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5)
(c (6) (E) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (2) (c (2) (0)
(c (2) (8) (c (3) (2) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (8) (c (2) (9) (c (2) (9)
(c (3) (B) (c (0) (A) (c (2) (8) (c (7) (2) (c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5)
(c (6) (E) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (2) (c (2) (0)
(c (2) (8) (c (3) (2) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (9) (c (2) (9) (c (2) (9)
(c (3) (B) (c (0) (A) (c (0) (A) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E)
(c (7) (4) (c (5) (F) (c (6) (8) (c (6) (5) (c (7) (8) (c (2) (0) (c (2) (8) (c (4) (1)
(c (2) (9) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0)
(c (2) (8) (c (3) (4) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (1) (c (2) (9) (c (2) (9)
(c (3) (B) (c (0) (A) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4)
(c (5) (F) (c (6) (8) (c (6) (5) (c (7) (8) (c (2) (0) (c (2) (8) (c (4) (2) (c (2) (9)
(c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8)
(c (3) (4) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (2) (c (2) (9) (c (2) (9) (c (3) (B)
(c (0) (A) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F)
(c (6) (8) (c (6) (5) (c (7) (8) (c (2) (0) (c (2) (8) (c (4) (3) (c (2) (9) (c (2) (9)
(c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (3) (4)
(c (2) (9) (c (2) (0) (c (2) (8) (c (3) (3) (c (2) (9) (c (2) (9) (c (3) (B) (c (0) (A)
(c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F) (c (6) (8)
(c (6) (5) (c (7) (8) (c (2) (0) (c (2) (8) (c (4) (4) (c (2) (9) (c (2) (9) (c (2) (0)
(c (3) (D) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9)
(c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9) (c (2) (9) (c (3) (B) (c (0) (A) (c (2) (8)
(c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F) (c (6) (8) (c (6) (5)
(c (7) (8) (c (2) (0) (c (2) (8) (c (4) (5) (c (2) (9) (c (2) (9) (c (2) (0) (c (3) (D)
(c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9) (c (2) (0)
(c (2) (8) (c (3) (5) (c (2) (9) (c (2) (9) (c (3) (B) (c (0) (A) (c (2) (8) (c (7) (0)
(c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F) (c (6) (8) (c (6) (5) (c (7) (8)
(c (2) (0) (c (2) (8) (c (4) (6) (c (2) (9) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0)
(c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9) (c (2) (0) (c (2) (8)
(c (3) (6) (c (2) (9) (c (2) (9) (c (3) (B) (c (0) (A) (c (2) (8) (c (7) (0) (c (7) (2)
(c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F) (c (6) (8) (c (6) (5) (c (7) (8) (c (2) (0)
(c (6) (4) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0)
(c (2) (8) (c (3) (3) (c (2) (9) (c (2) (0) (c (6) (4) (c (2) (9) (c (3) (B) (c (0) (A)
(c (0) (A) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (6) (2) (c (2) (0) (c (7) (8)
(c (2) (0) (c (7) (9) (c (2) (9) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8)
(c (6) (F) (c (2) (0) (c (7) (8) (c (2) (0) (c (7) (9) (c (2) (9) (c (3) (B) (c (0) (A)
(c (2) (8) (c (6) (F) (c (2) (0) (c (7) (8) (c (2) (0) (c (7) (9) (c (2) (9) (c (2) (0)
(c (3) (D) (c (2) (0) (c (2) (8) (c (7) (4) (c (6) (8) (c (6) (5) (c (6) (E) (c (2) (0)
(c (2) (8) (c (6) (F) (c (7) (5) (c (7) (4) (c (7) (0) (c (7) (5) (c (7) (4) (c (2) (0)
(c (2) (8) (c (6) (2) (c (7) (9) (c (7) (4) (c (6) (5) (c (2) (0) (c (7) (8) (c (2) (0)
(c (7) (9) (c (2) (9) (c (2) (9) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (9) (c (2) (9)
(c (3) (B) (c (0) (A) (c (2) (8) (c (7) (4) (c (6) (8) (c (6) (5) (c (6) (E) (c (2) (0)
(c (6) (1) (c (2) (0) (c (6) (2) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (6) (2)
(c (3) (B) (c (0) (A) (c (2) (8) (c (6) (4) (c (6) (F) (c (2) (0) (c (6) (1) (c (2) (9)
(c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (4) (c (6) (F) (c (2) (9) (c (3) (B)
(c (0) (A) (n))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))));
(main) =
    (do
        (before_data)
        (print_data (data) (z) (z))
        (print_code (data))
    );


(before_data) =
    (o (lparen) (6) (4) (6) (1) (7) (4) (6) (1) (rparen) (space) (3) (D) (space));


(print_data x (s (s (s (s (s (s (s (s (z)))))))))) =
    (do
        (o (0) (A))
        (print_data x (z))
        (o (0) (A))
    );
(print_data (c w x y) z) =
    (do
        (o (lparen) (6) (3) (space) (lparen))
        (print_hex w)
        (o (rparen) (space) (lparen))
        (print_hex x)
        (o (rparen) (space))
        (print_data y (s z))
        (o (rparen))
    );
(print_data (n)) = (o (lparen) (6) (E) (rparen));

(print_code (c x y z)) =
    (do
        (o x y)
        (print_code z)
    );

(space) = (b (2) (0));
(lparen) = (b (2) (8));
(rparen) = (b (2) (9));

(print_hex (A)) = (o (4) (1));
(print_hex (B)) = (o (4) (2));
(print_hex (C)) = (o (4) (3));
(print_hex (D)) = (o (4) (4));
(print_hex (E)) = (o (4) (5));
(print_hex (F)) = (o (4) (6));
(print_hex d) = (o (3) d);

(o (b x y)) = (o x y);
(o x y) = (then (output (byte x y)) (o));
(then a b) = b;
(do a) = (do);
"""

print(problems[0])

# collects human eval problems from github
!git clone https://github.com/openai/human-eval.git
# %cd human-eval
!ls data
!gunzip data/HumanEval.jsonl.gz
!ls data
!pip install transformers torch jsonlines
import jsonlines

problems = []

# Load the problems from the JSONL file
with jsonlines.open("data/HumanEval.jsonl") as f:
    for obj in f:
        problems.append(obj)

from openai import OpenAI

os.environ["OPENAI_API_KEY"] =
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

import os
import subprocess
import re
import ast
import zipfile
from google.colab import files as colab_files  # Alias

ESO_INTERPRETER_PATH = "/content/esolang0815_interpreter.py"

def execute_rhokell_code(code: str, test_input: str = "") -> str:
    """
    Writes the given Rhokell code to a temporary file and executes it using the Rhokell interpreter.
    Input data is piped to the interpreter.
    """
    try:
        temp_rhk_path = "temp.rhk"
        with open(temp_rhk_path, "w") as f:
            f.write(code)
        interpreter_cmd = ["rhokell", temp_rhk_path]
        result = subprocess.run(
            interpreter_cmd,
            input=test_input,
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode != 0:
            return f"Error: {result.stderr.strip()}"
        return result.stdout.strip()
    except subprocess.TimeoutExpired:
        return "Error: Execution timed out."
    except Exception as e:
        return f"Error during execution: {str(e)}"

def extract_rhokell_code(generated_content: str) -> str:
    """
    Extracts Rhokell code from a response using markdown code blocks.
    First, attempts to find code blocks marked with ```rhokell.
    If none is found, falls back to any triple-backtick code block.
    Finally, if no block is found but the content appears code-like, returns the full content.
    """
    # Try code block with language tag
    pattern_rhk = r"```rhokell\s+([\s\S]*?)```"
    codes = re.findall(pattern_rhk, generated_content, re.MULTILINE)
    if codes and codes[0].strip():
        return codes[0].strip()

    pattern_any = r"```\s*([\s\S]*?)```"
    codes_any = re.findall(pattern_any, generated_content, re.MULTILINE)
    if codes_any:
        candidate = codes_any[0].strip()
        # Optionally, check for common Rhokell keywords
        if any(kw in candidate for kw in ["(main", "(cons", "(byte", "(if", "(add"]):
            return candidate

    if "(" in generated_content and ")" in generated_content:
        return generated_content.strip()

    return ""

def extract_first_test(test_str: str) -> tuple:
    """
    Extracts the first test case from a test string.
    Expects an assertion in the form:
      assert candidate(<test_input>) == <expected_output>
    Returns a tuple: (test_input, expected_output)
    """
    pattern = re.compile(
        r'assert\s+candidate\((.*?)\)\s*==\s*('
        r'\[.*?\]|True|False|None|".*?"|\'.*?\'|[-+]?\d*\.\d+|\d+'
        r')'
    )
    match = pattern.search(test_str)
    if match:
        test_input = match.group(1).strip()
        expected_output = match.group(2).strip()
        return test_input, expected_output
    else:
        raise ValueError("No valid test case found in test string.")

def mod_prompt(prompt: str, feedback: str = "") -> str:
    """
    Modifies the prompt to instruct the assistant to write Rhokell code using the provided documentation.
    """
    if feedback:
        modified_prompt = (
            f"Using the following documentation for Rhokell:\n{rhokell_doc[:7000]}\n\n"
            f"Write a function in Rhokell that performs the following task: {prompt}\n"
            f"Feedback from previous attempt: {feedback}"
        )
    else:
        modified_prompt = (
            f"Using the following documentation for Rhokell:\n{rhokell_doc[:7000]}\n\n"
            f"Write a function in Rhokell that performs the following task: {prompt}"
        )
    return modified_prompt

# Folder where generated Rhokell code will be saved.
generated_code_folder = "/content/drive/MyDrive/Deepseekrhokell_generated_code"
os.makedirs(generated_code_folder, exist_ok=True)

results = []

for idx, problem in enumerate(problems):
    print(f"\nEvaluating Problem {idx+1}/{len(problems)}: {problem['task_id']}")
    try:
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "You are an assistant that writes Rhokell code."},
                {"role": "user", "content": mod_prompt(problem['prompt'])}
            ],
            temperature=0.0,
            max_tokens=350  # Adjust based on expected code length
        )
        generated_content = response.choices[0].message.content.strip()
        print(f"Generated Content:\n{generated_content[:500]}...\n")

        rhk_code = extract_rhokell_code(generated_content)
        print(f"Extracted Rhokell Code:\n{rhk_code}\n")

        if not rhk_code:
            raise ValueError("No Rhokell code found in the response.")

        problem_id = problem['task_id']
        sanitized_id = problem_id.replace("/", "_")
        code_file_path = os.path.join(generated_code_folder, f"{sanitized_id}.rhk")
        with open(code_file_path, "w") as code_file:
            code_file.write(rhk_code)

        # Extract first test case from the test string.
        test_input, expected_output = extract_first_test(problem['test'])
        print(f"Test Input: {test_input}\nExpected Output: {expected_output}\n")

        output = execute_rhokell_code(rhk_code, test_input)
        print(f"Rhokell Output:\n{output}\n")

        # Check compilability: if output starts with "Error:" then it's uncompilable.
        compilable = True
        if output.startswith("Error:"):
            compilable = False

        status = "correct" if expected_output.upper() in output.upper() else "wrong output"
        if not compilable:
            status = "uncompilable"

        results.append({
            "problem": problem["task_id"],
            "status": status,
            "compilable": compilable,
            "code": rhk_code,
            "output": output
        })

    except Exception as e:
        print(f"Error during evaluation: {e}")
        results.append({
            "problem": problem["task_id"],
            "status": "Error",
            "compilable": False,
            "error": str(e)
        })
print("\nFinal Results:")
for res in results:
    print(res)

print("\nFinal Results:")
totalpassed = 0
totalcompiled= 0
for res in results:
    if res['status'] == True:
         totalpassed += 1
    if res['compilable'] == True:
         totalcompiled += 1

print("percentage passed: " + str(100*totalpassed/ len(results)) + "%")
print("percentage compiled: " + str(100*totalcompiled/ len(results)) + "%")

# Zip the folder with generated Rhokell code
zip_filename = "Deepseekrhokell_generated_code.zip"
with zipfile.ZipFile(zip_filename, "w", zipfile.ZIP_DEFLATED) as zipf:
    for root, dirs, files in os.walk(generated_code_folder):
        for file in files:
            file_path = os.path.join(root, file)
            zipf.write(file_path, arcname=file)

# Download the zip file in Colab
colab_files.download(zip_filename)

