# -*- coding: utf-8 -*-
"""rhokell.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wW-BrRQ-8o6xDj0JIAO2qk8LyFOPQiIW
"""

!curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
import os
os.environ["PATH"] += ":/root/.cargo/bin"
!cargo install --git https://github.com/pro465/rhokell



# Initialize documentation storage
example_docs = "\n\n=== Examples from the repository ===\n"
examples_dir = "rhokell/examples"

# Collect all .rhk files (including inside subdirectories)
example_files = glob.glob(os.path.join(examples_dir, "**", "*.rhk"), recursive=True)

# Iterate over detected files and append their content
for filepath in example_files:
    if os.path.isfile(filepath):  # Ensure it's a file, not a directory
        with open(filepath, "r", encoding="utf-8") as f:
            content = f.read()
            relative_path = os.path.relpath(filepath, "rhokell/examples")  # Get relative path for clarity
            example_docs += f"\n----- {relative_path} -----\n```\n{content}\n```\n"

# Append examples to Rhokell documentation
rhokell_doc += example_docs

# Print first 1000 characters of the updated documentation (for verification)



rhokell_doc = r"""
rhokell
Paradigm(s)	Declarative, Functional
Designed by	User:Pro465
Appeared in	2023
Memory system	Tree based
Computational class	Turing complete
Major implementations	Rust
Influenced by	Haskell
File extension(s)	.rhk
rhokell created by User:Pro465 is a mixture of rho calculus + haskell. it consists of a list of rules separated by ;, each consisting of two untyped expressions separated by =.

it reduces greedily/applicative-order-ly. that means arguments are reduced before their functions. more specifically, for any expression (a b),

first a is reduced,
then b,
and finally (a b).
it also always applies the first match that is found, unlike haskell (which just throws an error).

example of peano addition:

(add (z) y) = (y);
(add (s x) y) = (s (add x y));
(yes I know it looks like lisp, but that's purely coincidental)

note that the pattern is required to not be just a variable, so we cannot write:

x = (s x);

Contents
1	Explanation
1.1	normal vs REPL vs RD mode
1.2	Difference between variable and function names
1.3	Data types
1.4	I/O
1.4.1	byte "data type"
1.4.2	Functions for I/O
2	Examples
2.1	text to cons list
2.2	Peano multiplication and exponentiation
2.3	Hello, world!
2.4	Truth Machine
2.5	Cat
2.6	Reverse cat
2.7	Kolakoski sequence
2.8	Quine
3	See also
4	Links
Explanation
normal vs REPL vs RD mode
In normal mode, the interpreter calls the (main) function if it is defined, and runs it.
In REPL mode, the interpreter evaluates an expression given by the user, and prints the resulting expression in a loop.
In RD (ResultDisplay) mode, the interpreter calls the (main) function if it is defined, and runs it. Then it prints the resulting expression.

The normal mode is required, while the REPL and RD modes are optional for any implementation.

Difference between variable and function names
first off, (a b c) is syntax sugar for (((a) b) c). secondly, an identifier is a group of contiguous alphanumeric unicode characters. OK, now we can talk.

the difference between a variable (that matches anything) and a function (that only matches itself) in the pattern side is easy:

If an expression is of the form (f) where f is an identifier, then f is a function name.
If, however, it is of the form (f v), where v is an identifier, then v is a variable name.
in other words, an identifier in argument position is a variable. otherwise, it's a function name.

However, in the replacement side (the RHS of the =), things are a bit more complex: what might seem to be "function names" can turn out to be actually variables when their name is bound to a variable in the pattern (the LHS). for example:

(if e1 e2 arg (F)) = (e2 arg);
here, even though e2 appears to be a function name, it is actually a variable due to being bound by the e2 in the pattern. If, however, e2 did not appear in the pattern, it would really be a function name much like if or F.

Data types
there are no data types. Instead data types are emulated by functions with no defined rules, like s x, or (cons a list).

I/O
byte "data type"
a (byte (a) (b)) represents a byte with its upper and lower half being a and b respectively. a and b are in hexadecimal. so it means 0x{a}{b} in other programming languages. For example: (byte (6) (F)) means 0x6F, which corresponds to the character 'o' in ascii.

Functions for I/O
two function names are special for I/O operations: input and output

(input) - reduces to the next byte given in standard input in the form of (byte (a) (b)). If there are no more bytes left, reduces to (EOF).
((output) (byte (a) (b))) - reduces to (output), while printing the byte to standard output. if the argument given is not of the form for byte given above, it does not print anything.
Examples
text to cons list
open in REPL mode, type (tr), press enter, then give input.

(tr) = (transform (input));
(transform (byte (0) (A))) = (cons (byte (0) (A)) (nil));
(transform x) = (cons x (transform (input)));
Peano multiplication and exponentiation
works only in repl mode

(add (z) y) = (y);
(add (s x) y) = (s (add x y));
(mul (z) y) = (z);
(mul (s x) y) = (add y (mul x y));
(exp x (z)) = (s (z));
(exp x (s y)) = (mul x (exp x y));
Hello, world!
Made with the help of the "text to cons list" program above.

(main) = (print
             (cons (byte (4) (8)) # "H"
             (cons (byte (6) (5)) # "e"
             (cons (byte (6) (C)) # "l"
             (cons (byte (6) (C)) # "l"
             (cons (byte (6) (F)) # "o"
             (cons (byte (2) (C)) # ","
             (cons (byte (2) (0)) # " "
             (cons (byte (7) (7)) # "w"
             (cons (byte (6) (F)) # "o"
             (cons (byte (7) (2)) # "r"
             (cons (byte (6) (C)) # "l"
             (cons (byte (6) (4)) # "d"
             (cons (byte (2) (1)) # "!"
             (cons (byte (0) (A)) # "\n"
                   (nil))))))))))))))));
(print (cons x y)) = (then (output x) (print y));
(then a b) = b;
Truth Machine
(main) = (a (input) (output));
(a (byte (3) (0)) o) = (o (byte (3) (0)));
(a x o) = (a x (o x));
Cat
(main) = (cat (input) (output));
(cat (EOF) o) = (do_nothing);
(cat x o) = (cat (input) (o x));
Reverse cat
(main) = (print (reverse (collect (input))));

(collect (EOF)) = (nil);
(collect b) = (cons b (collect (input)));

(print (cons x y)) = (then (output x) (print y));

(reverse (nil)) =  (nil);
(reverse (cons x y)) = (append (reverse y) (cons x (nil)));

(append (nil) x) = x;
(append (cons x y) z) = (cons x (append y z));

(then a b) = b;
Kolakoski sequence
uses O(log n) space and O(n) time to print to nth term.

# this implements a minor variant of the algorithm given here:
# https://www.emis.de/journals/JIS/VOL15/Nilsson/nilsson5.pdf
#
# specifically, instead of initializing P[k] with "22" before
# carrying out the increment logic,
# it simply returns after "setting" it to "2".

# first print "1, 2, "
(main) = (kolakoski (then (print (1) (2)) (nil)));

(kolakoski x) = (kolakoski (print_next (inc x)));

(inc (nil)) = (cons (2) (nil));
(inc (cons (t a) b)) = (cons a b);
(inc (cons a b)) = (repeat (inc b) (next a));

(repeat (cons a b) sym) = (cons (times (get a) sym) (cons a b));

(times (1) s) = s;
(times (2) s) = (t s);

(get (t b)) = b;
(get b) = b;

(next (1)) = (2);
(next (2)) = (1);

(print_next (cons a b)) = (then (print (get a)) (cons a b));
(print a) = (then (o (3) a (2) (C) (2) (0)) (print));
(o a b) = (then (output (byte a b)) (o));

(then a b) = b;
Quine
Warning: looong code wall incoming

(data) = (c (3) (B) (c (0) (A) (c (2) (8) (c (6) (D) (c (6) (1) (c (6) (9) (c (6) (E) (c (2) (9)
(c (2) (0) (c (3) (D) (c (2) (0) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (8) (c (6) (4) (c (6) (F) (c (2) (0) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (2) (c (6) (5)
(c (6) (6) (c (6) (F) (c (7) (2) (c (6) (5) (c (5) (F) (c (6) (4) (c (6) (1) (c (7) (4)
(c (6) (1) (c (2) (9) (c (2) (0) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9)
(c (6) (E) (c (7) (4) (c (5) (F) (c (6) (4) (c (6) (1) (c (7) (4) (c (6) (1) (c (2) (0)
(c (2) (8) (c (6) (4) (c (6) (1) (c (7) (4) (c (6) (1) (c (2) (9) (c (2) (0) (c (2) (8)
(c (7) (A) (c (2) (9) (c (2) (0) (c (2) (8) (c (7) (A) (c (2) (9) (c (2) (9) (c (2) (0)
(c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9) (c (6) (E) (c (7) (4) (c (5) (F)
(c (6) (3) (c (6) (F) (c (6) (4) (c (6) (5) (c (2) (0) (c (2) (8) (c (6) (4) (c (6) (1)
(c (7) (4) (c (6) (1) (c (2) (9) (c (2) (9) (c (0) (A) (c (2) (0) (c (2) (0) (c (2) (0)
(c (2) (0) (c (2) (9) (c (3) (B) (c (0) (A) (c (0) (A) (c (0) (A) (c (2) (8) (c (6) (2)
(c (6) (5) (c (6) (6) (c (6) (F) (c (7) (2) (c (6) (5) (c (5) (F) (c (6) (4) (c (6) (1)
(c (7) (4) (c (6) (1) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (0) (A) (c (2) (0)
(c (2) (0) (c (2) (0) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (6) (C)
(c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (0) (c (2) (8)
(c (3) (6) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9) (c (2) (0) (c (2) (8)
(c (3) (6) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (1) (c (2) (9) (c (2) (0) (c (2) (8)
(c (3) (7) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9) (c (2) (0) (c (2) (8)
(c (3) (6) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (1) (c (2) (9) (c (2) (0) (c (2) (8)
(c (7) (2) (c (7) (0) (c (6) (1) (c (7) (2) (c (6) (5) (c (6) (E) (c (2) (9) (c (2) (0)
(c (2) (8) (c (7) (3) (c (7) (0) (c (6) (1) (c (6) (3) (c (6) (5) (c (2) (9) (c (2) (0)
(c (2) (8) (c (3) (3) (c (2) (9) (c (2) (0) (c (2) (8) (c (4) (4) (c (2) (9) (c (2) (0)
(c (2) (8) (c (7) (3) (c (7) (0) (c (6) (1) (c (6) (3) (c (6) (5) (c (2) (9) (c (2) (9)
(c (3) (B) (c (0) (A) (c (0) (A) (c (0) (A) (c (2) (8) (c (7) (0) (c (7) (2) (c (6) (9)
(c (6) (E) (c (7) (4) (c (5) (F) (c (6) (8) (c (6) (5) (c (7) (8) (c (2) (0) (c (2) (8)
(c (4) (1) (c (2) (9) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (F)
(c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (1) (c (2) (9)
(c (2) (9) (c (2) (0) (c (2) (8) (c (3) (4) (c (2) (9) (c (2) (0) (c (2) (8) (c (3) (6)
(c (2) (9) (c (2) (0) (c (2) (8) (c (3) (5) (c (2) (9) (c (2) (9) (c (3) (B) (c (0) (A)
(c (2) (8) (c (6) (F) (c (2) (0) (c (2) (8) (c (6) (2) (c (2) (0) (c (7) (8) (c (2) (0)
(c (7) (9) (c (2) (9) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (2) (8) (c (6) (F)
(c (2) (0) (c (7) (8) (c (2) (0) (c (7) (9) (c (2) (9) (c (3) (B) (c (0) (A) (c (2) (8)
(c (6) (F) (c (2) (0) (c (7) (8) (c (2) (0) (c (7) (9) (c (2) (9) (c (2) (0) (c (3) (D)
(c (2) (0) (c (2) (8) (c (7) (4) (c (6) (8) (c (6) (5) (c (6) (E) (c (2) (0) (c (2) (8)
(c (6) (F) (c (7) (5) (c (7) (4) (c (7) (0) (c (7) (5) (c (7) (4) (c (2) (0) (c (2) (8)
(c (6) (2) (c (7) (9) (c (7) (4) (c (6) (5) (c (2) (0) (c (7) (8) (c (2) (0) (c (7) (9)
(c (2) (9) (c (2) (9) (c (2) (0) (c (2) (8) (c (6) (F) (c (2) (9) (c (2) (9) (c (3) (B)
(c (0) (A) (c (2) (8) (c (7) (4) (c (6) (8) (c (6) (5) (c (6) (E) (c (2) (0) (c (6) (1)
(c (2) (0) (c (6) (2) (c (2) (9) (c (2) (0) (c (3) (D) (c (2) (0) (c (6) (2) (c (3) (B)
(c (0) (A) (n))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
))))))))
)))))))))
)))))))))
)))))))))
)))))))))
)))))))))
)))))))))
)))))))))
)))))))))
)))))))))
))))))))
(main) =
    (do
        (before_data)
        (print_data (data) (z) (z))
        (print_code (data))
    );


(before_data) =
    (o (lparen) (6) (4) (6) (1) (7) (4) (6) (1) (rparen) (space) (3) (D) (space));


(print_data x (s (s (s (s (s (s (s (s (z)))))))))) =
    (do
        (o (0) (A))
        (print_data x (z))
        (o (0) (A))
    );
(print_data (c w x y) z) =
    (do
        (o (lparen) (6) (3) (space) (lparen))
        (print_hex w)
        (o (rparen) (space) (lparen))
        (print_hex x)
        (o (rparen) (space))
        (print_data y (s z))
        (o (rparen))
    );
(print_data (n)) = (o (lparen) (6) (E) (rparen));

(print_code (c x y z)) =
    (do
        (o x y)
        (print_code z)
    );

(space) = (b (2) (0));
(lparen) = (b (2) (8));
(rparen) = (b (2) (9));

(print_hex (A)) = (o (4) (1));
(print_hex (B)) = (o (4) (2));
(print_hex (C)) = (o (4) (3));
(print_hex (D)) = (o (4) (4));
(print_hex (E)) = (o (4) (5));
(print_hex (F)) = (o (4) (6));
(print_hex d) = (o (3) d);

(o (b x y)) = (o x y);
(o x y) = (then (output (byte x y)) (o));
(then a b) = b;
(do a) = (do);
"""

from openai import OpenAI
# Initialize results
results = []
os.environ["OPENAI_API_KEY"] =
# Initialize OpenAI client
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))


!curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
import os
os.environ["PATH"] += ":/root/.cargo/bin"

!cargo --version

# Install the Rhokell interpreter from GitHub
!cargo install --git https://github.com/pro465/rhokell

!echo "(main) = (print (cons (byte (4) (8)) (cons (byte (6) (5)) (nil)));" > hello_world.rhk
!echo "(main)" | rhokell -r hello_world.rhk

import re
import subprocess
import openai

from openai import OpenAI

# Set your OpenAI API key (replace with your actual key)
os.environ["OPENAI_API_KEY"] = 'YOUR_API_KEY_HERE'

def extract_rhokell_code(generated_content: str) -> str:
    """
    Extracts Rhokell code from a response using markdown code blocks.
    Expects code blocks marked with ```rhokell ... ```
    """
    pattern = r"```rhokell\s+([\s\S]*?)```"
    codes = re.findall(pattern, generated_content, re.MULTILINE)
    print("Extracted Rhokell Codes:", codes)
    return codes[0].strip() if codes else ""

def get_main_params(code: str) -> list:
    """
    Returns a list of parameter names for the (main ...) function if defined.
    For example, "(main n) = ..." returns ["n"] while "(main) = ..." returns [].
    """
    pattern = r"\(main\s*([^)]+)?\)\s*="
    match = re.search(pattern, code)
    if match:
        params = match.group(1)
        if params:
            return params.strip().split()
        else:
            return []
    return []

def decimal_to_peano(n: int) -> str:
    """
    Converts a nonnegative integer into its Peano numeral representation in Rhokell.
    For example, 0 -> (z), 1 -> (s (z)), 2 -> (s (s (z))), etc.
    """
    if n == 0:
        return "(z)"
    result = "(z)"
    for _ in range(n):
        result = f"(s {result})"
    return result

def execute_rhokell_code(code: str, test_input: str = "") -> str:
    """
    Writes the given Rhokell code to a temporary file and executes it.
    If the code defines a (main ...) function and does not already call it,
    then append a call to (main) with the provided input.

    If (main) has parameters and test_input is provided, we split the test input
    into tokens and (for numeric tokens) convert them into Peano numerals.
    Otherwise, if main is defined with no parameters, we simply append (print (main)).

    If no main function is found, the test_input is passed via standard input.
    """
    try:
        # If code defines a main function...
        if "(main" in code:
            # If no explicit call to (main) is already present, append one.
            if "(main)" not in code and "(main " not in code:
                main_params = get_main_params(code)
                if main_params and test_input.strip():
                    # For functions with parameters, split the test input (one token per line)
                    tokens = test_input.strip().split("\n")
                    args = []
                    for token in tokens:
                        token = token.strip()
                        if token.isdigit():
                            args.append(decimal_to_peano(int(token)))
                        else:
                            args.append(token)
                    # Build a call expression that wraps the call with (print …) so output is produced.
                    call_expr = f"(print (main {' '.join(args)}))"
                    code += "\n" + call_expr + "\n"
                else:
                    # If main has no parameters (or test_input is empty), just call it.
                    code += "\n(print (main))\n"
                # Clear test_input since we've appended the call
                test_input = ""
        # Write the code to a temporary file.
        temp_rhk_path = "temp.rhk"
        with open(temp_rhk_path, "w") as f:
            f.write(code)
        # Run the interpreter in normal mode (which will execute our appended call).
        interpreter_cmd = ["rhokell", temp_rhk_path]
        result = subprocess.run(
            interpreter_cmd,
            input=test_input,
            capture_output=True,
            text=True,
            timeout=5
        )
        if result.returncode != 0:
            return f"Error: {result.stderr.strip()}"
        return result.stdout.strip()
    except subprocess.TimeoutExpired:
        return "Error: Execution timed out."
    except Exception as e:
        return f"Error during execution: {str(e)}"





file_path = "/content/drive/MyDrive/esolangs/rhokell/rhokellexamples.py"
with open(file_path, "r", encoding="utf-8") as file:
    file_content = file.read()

def mod_prompt(prompt):
    """
    Modifies the prompt to instruct the assistant to write Rhokell code using the provided documentation.
    """
    modified_prompt = (
        f"Using the following documentation for Rhokell:\n{rhokell_doc[:7000]}\n\n"
        f"Write a function in Rhokell that performs the following task: {prompt}"
        f"Here are examples of Minipy Code: '{file_content}'."
    )
    return modified_prompt

# For numeric tasks we now assume that the test input is a decimal string that will be converted.
problems = [
    {
        'task_id': "1",
        'prompt': mod_prompt('print hello world'),
        "tests": ["", 'Hello, world!']
    },
    {
        'task_id': "2",
        'prompt': mod_prompt('given a number n input, return the nth factorial number'),
        "tests": ["5", "120"]
    },
    {
        'task_id': "3",
        'prompt': mod_prompt('given a number n, return "Even" if n is even, else "Odd"'),
        "tests": ["4", 'Even']
    },
    {
        'task_id': "4",
        'prompt': mod_prompt('given two numbers a and b, return their sum'),
        "tests": ["2 \n 3", "5"]
    },
    {
        'task_id': "5",
        'prompt': mod_prompt('given a number n, return True if it is prime, else False'),
        "tests": ["11", "True"]
    },
    {
        'task_id': "6",
        'prompt': mod_prompt('given a string s, return the reversed string'),
        "tests": ["hello", 'olleh']
    },
     {
        'task_id': "7",
        'prompt': mod_prompt('print "Hello, Pyth!"'),
        "tests": ["", 'Hello, Pyth!']
    },
    {
        'task_id': "8",
        'prompt': mod_prompt('given two numbers a and b, return their product'),
        "tests": ["2 \n 3", "6"]
    },
    {
        'task_id': "9",
        'prompt': mod_prompt('given a number n, return True if it is positive, else False'),
        "tests": ["10", "True"]
    },
    {
        'task_id': "10",
        'prompt': mod_prompt('given two strings s1 and s2, return their concatenation'),
        "tests": ['"foo", "bar"', 'foobar']
    },
    {
        'task_id': "11",
        'prompt': mod_prompt('given a number n, return its square'),
        "tests": ["4", "16"]
    },
    {
        'task_id': "12",
        'prompt': mod_prompt('given a string s, return the number of characters in the string'),
        "tests": ['"hello"', "5"]
    },
    {
        'task_id': "13",
        'prompt': mod_prompt('given two numbers a and b, return the smaller number'),
        "tests": ["3 \n 7", "3"]
    },
    {
        'task_id': "14",
        'prompt': mod_prompt('given a string s, return True if all characters in the string are vowels, else False'),
        "tests": ['"aeiou"', "True"]
    },
    {
        'task_id': "15",
        'prompt': mod_prompt('given two numbers a and b, return the absolute difference between them'),
        "tests": ["7 \n 3", "4"]
    },
    {
        'task_id': "16",
        'prompt': mod_prompt('given a string s and a number n, return the string repeated n times'),
        "tests": ['"abc", 3', 'abcabcabc']
    }
    ,{
      'task_id': "17",
      'prompt': mod_prompt('given a number n, return the Fibonacci sequence up to the nth term'),
      "tests": ["5", "[0, 1, 1, 2, 3]"]
  },
  {
      'task_id': "18",
      'prompt': mod_prompt('given a list of numbers, return the maximum number'),
      "tests": ["[3, 1, 4, 1, 5, 9]", "9"]
  },
  {
      'task_id': "19",
      'prompt': mod_prompt('given a string s, return True if it is a palindrome, else False'),
      "tests": ['"racecar"', "True"]
  },
  {
      'task_id': "20",
      'prompt': mod_prompt('given two numbers a and b, return their greatest common divisor'),
      "tests": ["8 \n 12", "4"]
  },
  {
      'task_id': "21",
      'prompt': mod_prompt('given a list of numbers, return the list sorted in ascending order'),
      "tests": ["[4, 2, 5, 1]", "[1, 2, 4, 5]"]
  },
  {
      'task_id': "22",
      'prompt': mod_prompt('given a number n, return True if it is a perfect square, else False'),
      "tests": ["16", "True"]
  },
  {
      'task_id': "23",
      'prompt': mod_prompt('given a string s, return the number of vowels in the string'),
      "tests": ['"hello"', "2"]
  },
  {
      'task_id': "24",
      'prompt': mod_prompt('given a list of numbers, return the sum of all numbers in the list'),
      "tests": ["[1, 2, 3, 4]", "10"]
  },
  {
      'task_id': "25",
      'prompt': mod_prompt('given a number n, return its binary representation as a string'),
      "tests": ["10", '"1010"']
  },
  {
      'task_id': "26",
      'prompt': mod_prompt('given two strings s1 and s2, return True if s1 is an anagram of s2, else False'),
      "tests": ['"listen", "silent"', "True"]
  },
  {
      'task_id': "27",
      'prompt': mod_prompt('given a number n, return the sum of digits in n'),
      "tests": ["1234", "10"]
  },
  {
      'task_id': "28",
      'prompt': mod_prompt('given a list of numbers, return True if all numbers are even, else False'),
      "tests": ["[2, 4, 6, 8]", "True"]
  },
  {
      'task_id': "29",
      'prompt': mod_prompt('given a string s, return the string in title case'),
      "tests": ['"hello world"', 'Hello World']
  },
  {
      'task_id': "30",
      'prompt': mod_prompt('given two numbers a and b, return True if a is divisible by b, else False'),
      "tests": ["10 \n 2", "True"]
  }

]



!pip install together
from together import Together



results = []
for idx, problem in enumerate(problems):
    print(f"Evaluating Problem {idx+1}/{len(problems)}: {problem['task_id']}")
    try:
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "You are an assistant that writes Rhokell code."},
                {"role": "user", "content": mod_prompt(problem['prompt'])}
            ],
            temperature=0.0,
            max_tokens=350
        )
        generated_content = response.choices[0].message.content.strip()
        print(f"Generated Content:\n{generated_content}\n")
        rhk_code = extract_rhokell_code(generated_content)
        if not rhk_code:
            print("No Rhokell code found in the response.")
            results.append({'problem': problem['task_id'], 'status': 'uncompilable', 'code': generated_content, 'output': None})
            continue
        print(f"Selected Rhokell Code:\n{rhk_code}\n")
        output = execute_rhokell_code(rhk_code, problem['tests'][0])
        print(f"Rhokell Output:\n{output}\n")
        # Determine status based on output.
        if output.startswith("Error:"):
            status = "uncompilable"
        else:
            status = "correct" if problem['tests'][1].upper() in output.upper() else "wrong output"
        print("Status:", status)
        results.append({
            'problem': problem['task_id'],
            'status': status,
            'pass': problem['tests'][1].upper() in output.upper() ,
            'code': rhk_code,
            'output': output
        })
    except Exception as e:
        print(f"Error during API call: {e}")

total = len(results)
compiled = sum(1 for r in results if r['status'] in ['correct', 'wrong output'])
correct = sum(1 for r in results if r['status'] == 'correct')
wrong_output = sum(1 for r in results if r['status'] == 'wrong output')
uncompilable = sum(1 for r in results if r['status'] == 'uncompilable')

print("\n=== Summary ===")
print(f"Total Problems Evaluated: {total}")
print(f"Compiled without errors: {compiled} ({compiled/total*100:.2f}%)")
print(f"  - Correct Output: {correct} ({correct/total*100:.2f}%)")
print(f"  - Wrong Output: {wrong_output} ({wrong_output/total*100:.2f}%)")
print(f"Uncompilable Code: {uncompilable} ({uncompilable/total*100:.2f}%)")



