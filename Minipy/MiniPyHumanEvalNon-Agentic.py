# -*- coding: utf-8 -*-
"""minipyeval.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Lr-ToLWeci-Thqq6PdsUcOxZmT6iz7Y
"""

# Save the Minipy boilerplate as minipy.py
minipy_code = """
import sys as y
av = y.argv
if len(av) > 1:
    v1 = av[1]
    try:
        v2 = eval(v1)
    except SyntaxError: pass
import os
import re
import functools as ft
import string as st
import copy as cp
import random as rd
import math as m
ri = rd.randint
rt = lambda seq: seq[ri(0, len(seq)-1)]
N = None
_i = __import__
_b = __builtins__
_B = dir(_b)
ab = abs
al = all
an = any
bn = bin
c = chr
cx = complex
d = dict
dr = dir
em = enumerate
e = eval
x = exec
b = lambda x: lambda y: eval(x)
fm = lambda x,y: map(b(x),y)
ff = lambda x,y: filter(b(x),y)
fr = ft.reduce
fl = float
gtat = getattr
hsat = hasattr
dlat = delattr
stat = setattr
hx = hex
i = input
n = lambda *args: eval(input(*args))
sr = ""
t = int
l = len
ls = list
ot = oct
o = open
f = lambda s: o(s).read()
p = print
r = range
rp = repr
rvr = reversed
rnd = round
srt = sorted
s = str
sm = sum
v = vars
z = zip
def rf(s): # regex finder
    index = s.index("!")
    regex = re.compile(s[:index])
    search = s[index + 1 :]
    if search[0] == "!":
        return regex.findall(search[1:])
    else:
        return regex.findall(eval(search))
q = chr(34)
k = "\\n"

def e(s):
    raise RuntimeError(s)
"""
with open("minipy.py", "w") as f:
    f.write(minipy_code)

# Save the interpreter as interpreter.py
interpreter_code = "from minipy import *; x(f(v1))"
with open("interpreter.py", "w") as f:
    f.write(interpreter_code)

print("Minipy and interpreter setup complete!")

from google.colab import drive
drive.mount('/content/drive')

file_path = "/content/drive/MyDrive/esolangs/minipy/minipyexamples.py"  # Update with the actual file path

with open(file_path, "r", encoding="utf-8") as file:
    file_content = file.read()

import openai
import os
import os
import subprocess
import re
from openai import OpenAI

os.environ["OPENAI_API_KEY"] =
results = []
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

def mod_prompt(prompt):
    """
    Modifies the prompt to ask for a function written in Minipy.
    """
    modified_prompt = (
        f"Write a function in Minipy, an esoteric programming language. "
        f"The function should perform the following: {prompt}\n"
        f"Minipy is a shorthand for Python. Use all available shorthands. "
        f"Here is the Minipy documentation: '{minipy_code}'. Also be sure to label your code as minipy"
        f"Here are examples of Minipy Code: '{file_content}'."
    )
    return modified_prompt
print(mod_prompt("add tow numbers"))

import os
import subprocess
import tempfile
import re

def execute_py_code(code: str, input_data: str = "") -> str:
    """
    Executes Python code and returns the output.
    """
    try:
        # Create a temporary file to hold the Python code
        with tempfile.NamedTemporaryFile(mode="w+", suffix=".py", delete=False) as temp_py:
            temp_py_path = temp_py.name
            temp_py.write(code)

        try:
            # Execute the Python code
            result = subprocess.run(
                ['python3', temp_py_path],
                input=input_data,
                capture_output=True,
                text=True,
                timeout=5  # Adjust the timeout as needed
            )

            # Check for errors during execution
            if result.returncode != 0:
                return f"Error: {result.stderr.strip()}"

            # Return the standard output from the script
            return result.stdout.strip()

        finally:
            # Clean up the temporary file
            os.remove(temp_py_path)

    except subprocess.TimeoutExpired:
        return True
    except Exception as e:
        return True

def test_py_function(py_code: str, func_name: str, args: list, input_data: str = "") -> str:
    """
    Extracts function definitions from Python code, handles lambda and def functions,
    calls the specified function with arguments, executes the combined code, and returns the output.
    """
    try:
        # Determine if we have multiple arguments (tuple) or a single argument
        if isinstance(args, tuple):
            # Multiple arguments
            formatted_args = []
            for arg in args:
                if isinstance(arg, str):
                    # Enclose string arguments in quotes
                    formatted_args.append(f'"{arg}"')
                else:
                    # Use repr for other types to ensure correct formatting
                    formatted_args.append(repr(arg))
            args_str = ', '.join(formatted_args)
        else:
            # Single argument
            if isinstance(args, str):
                args_str = f'"{args}"'
            else:
                args_str = repr(args)

        # Create the function call string
        function_call = f"print({func_name}({args_str}))"

        # Combine with the userâ€™s Minipy code
        combined_code = f"{py_code.strip()}\n\n{function_call}"

        # Execute the combined code
        output = execute_py_code(combined_code, input_data)
        return any(keyword in output for keyword in ["Error", "Exception"])


    except Exception as e:
        return True

# Commented out IPython magic to ensure Python compatibility.
# collects human eval problems from github
!git clone https://github.com/openai/human-eval.git
# %cd human-eval
!ls data
!gunzip data/HumanEval.jsonl.gz
!ls data
!pip install transformers torch jsonlines
import jsonlines

problems = []

# Load the problems from the JSONL file
with jsonlines.open("data/HumanEval.jsonl") as f:
    for obj in f:
        problems.append(obj)







import os
import subprocess
import tempfile
import re
import ast
import functools as ft
import random as rd
import io
import contextlib
from typing import List, Tuple, Any
def mod_prompt(prompt):
    """
    Modifies the prompt to ask for a function written in Minipy.
    """
    modified_prompt = (
        f"Write a function in Minipy, an esoteric programming language. "
        f"The function should perform the following: {prompt}\n"
        f"Minipy is a shorthand for Python. Use all available shorthands. "
        f"Here is the Minipy documentation: '{minipy_code}'. Also be sure to label your code as minipy"
        f"Here are examples of Minipy Code: '{file_content}'."
    )
    return modified_prompt

##############################################################################
def parse_test_input(arg_str: str):
    """
    Parses a test input string into proper Python values.
    - If the string is empty, returns None.
    - If the string contains newline characters (and no commas), splits on newlines.
    - Otherwise, tries to use ast.literal_eval to get numbers, tuples, etc.
    If literal_eval fails, returns the raw string.
    """
    arg_str = arg_str.strip()
    if not arg_str:
        return None
    if "\n" in arg_str and "," not in arg_str:
        parts = [x.strip() for x in arg_str.splitlines() if x.strip()]
        parsed_parts = []
        for part in parts:
            try:
                parsed_parts.append(ast.literal_eval(part))
            except Exception:
                parsed_parts.append(part)
        return tuple(parsed_parts)
    else:
        try:
            return ast.literal_eval(arg_str)
        except Exception:
            return arg_str

def remove_type_hints(code: str) -> str:
    """
    Removes type annotations that reference List[...] from the code.
    This prevents errors like "NameError: name 'List' is not defined".
    """
    # Remove parameter type hints like ": List[...]"
    code = re.sub(r":\s*List\[[^\]]+\]", "", code)
    # Remove return type hints like "-> List[...]"
    code = re.sub(r"->\s*List\[[^\]]+\]", "", code)
    return code

def get_num_params(code: str, func_name: str) -> int:
    """
    Extracts the number of parameters from the function definition in the provided code.
    """
    pattern = rf"def\s+{func_name}\s*\((.*?)\):"
    match = re.search(pattern, code)
    if match:
        params = match.group(1).strip()
        if not params:
            return 0
        # Simple split on commas
        param_list = [p.strip() for p in params.split(',')]
        return len(param_list)
    return 0

###############################################
# Functions for executing and testing Python code
###############################################

def execute_py_code(code: str, input_data: str = "") -> str:
    """
    Executes Python code and returns the output, or an error message.
    This version mirrors the Minipy execute function except it writes a .py file
    and calls 'python3'.
    """
    try:
        # Create a temporary file to hold the Python code
        with tempfile.NamedTemporaryFile(mode="w+", suffix=".py", delete=False) as temp_py:
            temp_py_path = temp_py.name
            temp_py.write(code)
        try:
            # Execute the Python code using the interpreter
            result = subprocess.run(
                ['python3', temp_py_path],
                input=input_data,
                capture_output=True,
                text=True,
                timeout=5  # Adjust timeout as needed
            )
            if result.returncode != 0:
                return f"Error: {result.stderr.strip()}"
            return result.stdout.strip()
        finally:
            os.remove(temp_py_path)
    except subprocess.TimeoutExpired:
        return "Error: Execution timed out."
    except Exception as e:
        return f"Error during execution: {str(e)}"

def test_py_function(py_code: str, func_name: str, args: Any, input_data: str = "") -> str:
    """
    Executes the specified function in the provided Python code with the given arguments.
    This version mirrors the Minipy test function:
      - It determines the number of parameters expected.
      - If one parameter is expected, it passes the entire input as a single argument.
      - Otherwise, if args is a tuple or list, it unpacks them.
    """
    try:
        num_params = get_num_params(py_code, func_name)
        if isinstance(args, str):
            parsed = parse_test_input(args)
        else:
            parsed = args

        if parsed is None:
            args_str = ""
        elif num_params == 1:
            args_str = repr(parsed)
        elif isinstance(parsed, (tuple, list)):
            args_str = ', '.join(repr(x) for x in parsed)
        else:
            args_str = repr(parsed)

        # Construct the function call and combine with the provided code.
        function_call = f"print({func_name}({args_str}))"
        combined_code = f"{py_code.strip()}\n\n{function_call}"
        output = execute_py_code(combined_code, input_data)
        return output
    except Exception as e:
        return f"Error during testing: {str(e)}"

###############################################
# Functions for checking code against test cases
###############################################

def check_py_code(py_code: str, func_name: str, test_cases: List[Tuple[Any, Any]]) -> dict:
    """
    Checks if the provided Python code compiles and produces correct output for given test cases.
    This version mirrors the Minipy check function but uses our Python execution functions.

    Returns a dictionary with:
      - 'compilable': Boolean indicating if the code compiled.
      - 'compilation_error': Error message if compilation failed.
      - 'test_results': List of dictionaries for each test case.
      - 'all_tests_passed': Boolean indicating if all test cases passed.
    """
    result = {
        'compilable': True,
        'compilation_error': None,
        'test_results': [],
        'all_tests_passed': True
    }

    # Check if code compiles by simply executing it without a function call.
    compile_output = execute_py_code(py_code)
    if compile_output.startswith("Error:"):
        result['compilable'] = False
        result['compilation_error'] = compile_output
        return result

    # Run each test case.
    for idx, (inputs, expected) in enumerate(test_cases, start=1):
        # If inputs is not a list or tuple, wrap it.
        if not isinstance(inputs, (list, tuple)):
            args = [inputs]
        else:
            args = list(inputs) if isinstance(inputs, tuple) else inputs
        output = test_py_function(py_code, func_name, args)
        passed = (str(expected) == output)
        if not passed:
            result['all_tests_passed'] = False
        result['test_results'].append({
            'test_case': idx,
            'input': inputs,
            'expected': expected,
            'output': output,
            'passed': passed
        })
    return result

def check_minipy_code(minipy_code: str, func_name: str, test_cases: List[Tuple[Any, Any]]) -> dict:
    """
    Checks if the provided Minipy code compiles and produces correct output for given test cases.

    Returns a dictionary with:
      - 'compilable': Boolean indicating if the code compiled.
      - 'compilation_error': Error message if compilation failed.
      - 'test_results': List of dictionaries for each test case.
      - 'all_tests_passed': Boolean indicating if all test cases passed.
    """
    result = {
         'compilable': True,
         'compilation_error': None,
         'test_results': [],
         'all_tests_passed': True
    }

    compile_output = execute_minipy_code(minipy_code)
    if compile_output.startswith("Error:"):
         result['compilable'] = False
         result['compilation_error'] = compile_output
         return result

    for idx, (inputs, expected) in enumerate(test_cases, start=1):
         output = test_minipy_function(minipy_code, func_name, inputs)
         passed = (str(expected) == output)
         if not passed:
              result['all_tests_passed'] = False
         result['test_results'].append({
             'test_case': idx,
             'input': inputs,
             'expected': expected,
             'output': output,
             'passed': passed
         })

    return result

# Assume that the Minipy functions (execute_minipy_code and test_minipy_function)
# are defined elsewhere and work as expected.
# For completeness, here is a dummy version:
def execute_minipy_code(code: str, input_data: str = "") -> str:
    """
    Executes Minipy code and returns the output, or an error message.
    """
    try:
        # Ensure the Minipy interpreter exists
        if not os.path.isfile(MINIPY_INTERPRETER_PATH):
            return f"Error: Minipy interpreter not found at '{MINIPY_INTERPRETER_PATH}'."

        # Create a temporary file to hold the Minipy code
        with tempfile.NamedTemporaryFile(mode="w+", suffix=".minipy", delete=False) as temp_minipy:
            temp_minipy_path = temp_minipy.name
            temp_minipy.write(code)

        try:
            # Execute the Minipy code using the interpreter
            result = subprocess.run(
                ['python3', MINIPY_INTERPRETER_PATH, temp_minipy_path],
                input=input_data,
                capture_output=True,
                text=True,
                timeout=5  # Adjust as needed
            )

            # Check for errors during execution
            if result.returncode != 0:
                return f"Error: {result.stderr.strip()}"

            # Return the standard output
            return result.stdout.strip()
        finally:
            # Clean up the temp file
            os.remove(temp_minipy_path)

    except subprocess.TimeoutExpired:
        return "Error: Execution timed out."
    except Exception as e:
        return f"Error during execution: {str(e)}"


def test_minipy_function(minipy_code: str, func_name: str, args: Any, input_data: str = "") -> str:
    """
    Executes the specified function in the provided Minipy code with the given arguments.
    'args' can be a single value or a tuple/list of values.
    """
    try:
        # Determine if we have multiple arguments (tuple) or a single argument
        if isinstance(args, tuple):
            formatted_args = []
            for arg in args:
                if isinstance(arg, str):
                    formatted_args.append(f'"{arg}"')
                else:
                    formatted_args.append(repr(arg))
            args_str = ', '.join(formatted_args)
        else:
            if isinstance(args, str):
                args_str = f'"{args}"'
            else:
                args_str = repr(args)

        # Create the function call string
        function_call = f"print({func_name}({args_str}))"
        combined_code = f"{minipy_code.strip()}\n\n{function_call}"
        output = execute_minipy_code(combined_code, input_data)
        return output
    except Exception as e:
        return f"Error during testing: {str(e)}"


###############################################
# --- Main Testing Pipeline ---
###############################################
# Assume 'problems' is a list of dictionaries with keys 'task_id', 'prompt', and 'test'
# and that mod_prompt and client (OpenAI client) are defined elsewhere.

results = []
for idx, problem in enumerate(problems):  # or use a subset if desired
    print(f"Evaluating Problem {idx+1}/{len(problems)}: {problem['task_id']}")
    try:
        #print(mod_prompt(problem['prompt']))
        response = client.chat.completions.create(
            model="gpt-4o",  # Replace with your model
            messages=[
                {
                    "role": "system",
                    "content": (
                        f"You are an assistant that writes Minipy, the esoteric programming language code. "
                        f"Minipy is basically a shorthand for Python. The documentation {minipy_code} is provided here. "
                        "Please use all shorthands where applicable and label your code as minipy. "
                    ),

                },
                {
                    "role": "user",
                    "content": mod_prompt(problem['prompt'] + "In addition if creating a lambda function, call it f."),
                }
            ],
            temperature=0.0,
            max_tokens=500
        )

        generated_content = response.choices[0].message.content.strip()
        print(f"Generated Minipy Code:\n{generated_content}\n")

        minipy_code_extracted = extract_minipy_code(generated_content)
        print(f"Extracted Minipy Code:\n{minipy_code_extracted}\n")

        func_name = extract_function_name_and_convert(minipy_code_extracted)
        if func_name:
            print(f"Detected function definition: {func_name}")
        else:
            func_name = "f"
            print("Defaulting to function name 'f'.")

        parsed_test_cases = parse_test_cases(problem['test'])
        print(f"Parsed Test Cases: {parsed_test_cases}")

        minipy_check_result = check_minipy_code(minipy_code_extracted, func_name, parsed_test_cases)
        print(f"Minipy Check Result: {minipy_check_result}")

        py_check_result = check_py_code(minipy_code_extracted, func_name, parsed_test_cases)
        print(f"Python Check Result: {py_check_result}")

        results.append({
            'problem': problem['task_id'],
            'code': minipy_code_extracted,
            'minipy_check': minipy_check_result,
            'python_check': py_check_result
        })

    except Exception as e:
        print(f"Error during evaluation: {e}")
        results.append({
            'problem': problem['task_id'],
            'minipy_check': {
                'compilable': False,
                'compilation_error': f"Error: {e}"
            },
            'python_check': {
                'compilable': False,
                'compilation_error': f"Error: {e}"
            }
        })

# Optionally, further process or output the `results` as needed.



passed = 0
non_executable = 0
compiled = 0
totalcount = 0
print(results)
for result in results:
    print(f"Problem {result['problem']}:")
    if result['minipy_check']['compilation_error']:
        continue
    totalcount += 1
    print(f"Minipy tests passed: {result['minipy_check']['all_tests_passed']}")
    print(f"Python tests passed: {result['python_check']['all_tests_passed']}")
    print(f"Minipy code:\n{result.get('code', '<no code provided>')}")
    print(f"Minipy compilable: {result['minipy_check']['compilable']}")
    print(f"Python compilable: {result['python_check']['compilable']}")
    print("-" * 40)

    if result['minipy_check']['all_tests_passed']:
        passed += 1
    if result['minipy_check']['compilable']:
        compiled += 1
    # Count problems that pass the Minipy tests but do not pass Python tests.
    if result['minipy_check']['all_tests_passed'] and not result['python_check']['all_tests_passed']:
        non_executable += 1

print(f"Passed (Minipy tests): {passed}/{totalcount}")
print(f"Minipy compilable: {compiled}/{totalcount}")
print(f"Passed (Minipy tests) but not executable via Python: {non_executable}/{totalcount}")

import os
from google.colab import files

# Directory to store problem files
directory = "/content/4o-MiniPyHumanEval"
os.makedirs(directory, exist_ok=True)

def save_problems(results):
    passed = 0
    nonexecut = 0

    for result in results:
        # Replace slashes with underscores to form a valid filename
        problem_num = result['problem'].replace("/", "_")
        filename = os.path.join(directory, f"problem_{problem_num}.py")
        if 'code' in result:
          with open(filename, "w") as f:
              f.write(f"# Problem {result['problem']}\n")
              f.write(result['code'] + "\n")

save_problems(results)

import shutil
from google.colab import files

# Zip the folder
shutil.make_archive('/content/4o-MiniPyHumanEval', 'zip', '/content/4o-MiniPyHumanEval')

# Download the zip file
files.download('/content/4o-MiniPyHumanEval.zip')