# -*- coding: utf-8 -*-
"""minipysimple.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pVF4hRVxLBTWxmvrhfgsaTiPWAMmglS_
"""

# Save the Minipy boilerplate as minipy.py
minipy_code = """
import sys as y
av = y.argv
if len(av) > 1:
    v1 = av[1]
    try:
        v2 = eval(v1)
    except SyntaxError: pass
import os
import re
import functools as ft
import string as st
import copy as cp
import random as rd
import math as m
ri = rd.randint
rt = lambda seq: seq[ri(0, len(seq)-1)]
N = None
_i = __import__
_b = __builtins__
_B = dir(_b)
ab = abs
al = all
an = any
bn = bin
c = chr
cx = complex
d = dict
dr = dir
em = enumerate
e = eval
x = exec
b = lambda x: lambda y: eval(x)
fm = lambda x,y: map(b(x),y)
ff = lambda x,y: filter(b(x),y)
fr = ft.reduce
fl = float
gtat = getattr
hsat = hasattr
dlat = delattr
stat = setattr
hx = hex
i = input
n = lambda *args: eval(input(*args))
sr = ""
t = int
l = len
ls = list
ot = oct
o = open
f = lambda s: o(s).read()
p = print
r = range
rp = repr
rvr = reversed
rnd = round
srt = sorted
s = str
sm = sum
v = vars
z = zip
def rf(s): # regex finder
    index = s.index("!")
    regex = re.compile(s[:index])
    search = s[index + 1 :]
    if search[0] == "!":
        return regex.findall(search[1:])
    else:
        return regex.findall(eval(search))
q = chr(34)
k = "\\n"

def e(s):
    raise RuntimeError(s)
"""
with open("minipy.py", "w") as f:
    f.write(minipy_code)

# Save the interpreter as interpreter.py
interpreter_code = "from minipy import *; x(f(v1))"
with open("interpreter.py", "w") as f:
    f.write(interpreter_code)

print("Minipy and interpreter setup complete!")



!pip install transformers torch jsonlines

import os
import subprocess
import tempfile
import re
import ast
from typing import List, Tuple, Any

MINIPY_INTERPRETER_PATH = "/content/interpreter.py"  # Adjust if needed

def execute_minipy_code(code: str, input_data: str = "") -> str:
    """
    Executes Minipy code and returns the output, or an error message.
    """
    try:
        # Ensure the Minipy interpreter exists
        if not os.path.isfile(MINIPY_INTERPRETER_PATH):
            return f"Error: Minipy interpreter not found at '{MINIPY_INTERPRETER_PATH}'."

        # Create a temporary file to hold the Minipy code
        with tempfile.NamedTemporaryFile(mode="w+", suffix=".minipy", delete=False) as temp_minipy:
            temp_minipy_path = temp_minipy.name
            temp_minipy.write(code)

        try:
            # Execute the Minipy code using the interpreter
            result = subprocess.run(
                ['python3', MINIPY_INTERPRETER_PATH, temp_minipy_path],
                input=input_data,
                capture_output=True,
                text=True,
                timeout=5  # Adjust as needed
            )

            # Check for errors during execution
            if result.returncode != 0:
                return f"Error: {result.stderr.strip()}"

            # Return the standard output
            return result.stdout.strip()
        finally:
            # Clean up the temp file
            os.remove(temp_minipy_path)

    except subprocess.TimeoutExpired:
        return "Error: Execution timed out."
    except Exception as e:
        return f"Error during execution: {str(e)}"


def test_minipy_function(minipy_code: str, func_name: str, args: Any, input_data: str = "") -> str:
    """
    Executes the specified function in the provided Minipy code with the given arguments.
    'args' can be a single value or a tuple/list of values.
    """
    try:
        # Determine if we have multiple arguments (tuple) or a single argument
        if isinstance(args, tuple):
            # Multiple arguments
            formatted_args = []
            for arg in args:
                if isinstance(arg, str):
                    # Enclose string arguments in quotes
                    formatted_args.append(f'"{arg}"')
                else:
                    # Use repr for other types to ensure correct formatting
                    formatted_args.append(repr(arg))
            args_str = ', '.join(formatted_args)
        else:
            # Single argument
            if isinstance(args, str):
                args_str = f'"{args}"'
            else:
                args_str = repr(args)

        # Create the function call string
        function_call = f"print({func_name}({args_str}))"

        # Combine with the userâ€™s Minipy code
        combined_code = f"{minipy_code.strip()}\n\n{function_call}"

        # Execute the combined code
        output = execute_minipy_code(combined_code, input_data)
        return output
    except Exception as e:
        return f"Error during testing: {str(e)}"



def parse_test_cases(test_str: str) -> List[Tuple[Any, Any]]:
    """
    Parses a string containing Python asserts of the form:
        assert candidate(...) == <expected>
    or
        assert abs(candidate(...) - <expected>) < <tolerance>
    Returns a list of (input_args, expected_value).
    """
    test_cases = []

    # Pattern for parsing from assert candidate(...) check function in
    # human eval test cases
    pattern_eq = re.compile(
        r'assert\s+candidate\((.*?)\)\s*==\s*('
        r'\[.*?\]'         # lists
        r'|True|False'     # bool
        r'|None'           # None
        r'|".*?"'          # double-quoted
        r'|\'.*?\''        # single-quoted
        r'|[-+]?\d*\.\d+|\d+'  # int/float
        r')',
        re.DOTALL
    )

    # Pattern for approximate equality from
    # assert abs(candidate(...) - something) < tolerance check function in
    # human eval test cases
    pattern_approx_eq = re.compile(
        r'assert\s+abs\s*\(\s*candidate\((.*?)\)\s*-\s*(.*?)\s*\)\s*<\s*('
        r'[-+]?\d*\.\d+|\d+'  # Tolerance
        r')',
        re.DOTALL
    )

    matches_eq = pattern_eq.findall(test_str)
    for idx, (args_str, expected_str) in enumerate(matches_eq, 1):
        try:
            # Clean up
            args_str_clean = args_str.strip()
            expected_str_clean = expected_str.strip()

            # ast.literal_eval can parse it as a proper string.
            input_args = ast.literal_eval(args_str_clean)

            # Safely evaluate expected
            expected_output = ast.literal_eval(expected_str_clean)

            test_cases.append((input_args, expected_output))
        except Exception as e:
            print(f"Error parsing direct equality test case {idx}: {e}")
            continue

    matches_approx_eq = pattern_approx_eq.findall(test_str)
    for idx, (args_str, expected_str, tolerance_str) in enumerate(matches_approx_eq, 1):
        try:
            args_str_clean = args_str.strip()
            expected_str_clean = expected_str.strip()
            tolerance = float(tolerance_str.strip())

            input_args = ast.literal_eval(args_str_clean)
            expected_output = ast.literal_eval(expected_str_clean)
            test_cases.append((input_args, expected_output))
        except Exception as e:
            print(f"Error parsing approximate equality test case {idx}: {e}")
            continue

    return test_cases


def extract_function_name_and_convert(minipy_code: str) -> str:
    """
    Extracts the name of the first function defined via 'def name(...)' from Minipy code.
    """
    pattern = r"def\s+(\w+)\s*\("
    match = re.search(pattern, minipy_code)
    if match:
        return match.group(1)
    return ""


def extract_minipy_code(generated_content: str) -> str:
    """
    Extracts the Minipy code block from triple-backtick fences. If no closing
    fence is found, will return everything after ```minipy.
    """
    # Regex for normal labeled 'minipy'
    code_pattern = r"```minipy\s*\n([\s\S]*?)```"
    match = re.search(code_pattern, generated_content)
    if match:
        return match.group(1).strip()

    # regex if no forgot the closing backticks
    incomplete_pattern = r"```minipy\s*\n([\s\S]*)"
    incomplete_match = re.search(incomplete_pattern, generated_content)
    if incomplete_match:
        return incomplete_match.group(1).strip()

    # regex for any triple-backtick code block
    fallback_pattern = r"```\s*\n([\s\S]*?)```"
    fallback_match = re.search(fallback_pattern, generated_content)
    if fallback_match:
        return fallback_match.group(1).strip()

    # No block found
    return "Error: No valid Minipy code block found."

import re
import os
import openai
from typing import List
from google.colab import files

!pip install together











# Initialize results
results = []

def mod_prompt(prompt):
   modified_prompt = (
        f"Write a function in Pyth, an esoteric programming language. "
        f"The function should perform the following: {prompt}"
        f"The documentation for Pyth is provided here: '{minipy_code}'. "

    )
   return modified_prompt

problems = [
    {
        'task_id': "1",
        'prompt': mod_prompt('print hello world'),
        "tests": ["", 'Hello world']
    },
    {
        'task_id': "2",
        'prompt': mod_prompt('given a number n input, return the nth factorial number'),
        "tests": ["5", "120"]
    },
    {
        'task_id': "3",
        'prompt': mod_prompt('given a number n, return "Even" if n is even, else "Odd"'),
        "tests": ["4", '"Even"']
    },
    {
        'task_id': "4",
        'prompt': mod_prompt('given two numbers a and b, return their sum'),
        "tests": ["2 \n 3", "5"]
    },
    {
        'task_id': "5",
        'prompt': mod_prompt('given a number n, return True if it is prime, else False'),
        "tests": ["11", "True"]
    },
    {
        'task_id': "6",
        'prompt': mod_prompt('given a string s, return the reversed string'),
        "tests": ["hello", '"olleh"']
    },
     {
        'task_id': "7",
        'prompt': mod_prompt('print "Hello, Pyth!"'),
        "tests": ["", '"Hello, Pyth!"']
    },
    {
        'task_id': "8",
        'prompt': mod_prompt('given two numbers a and b, return their product'),
        "tests": ["2 \n 3", "6"]
    },
    {
        'task_id': "9",
        'prompt': mod_prompt('given a number n, return True if it is positive, else False'),
        "tests": ["10", "True"]
    },
    {
        'task_id': "10",
        'prompt': mod_prompt('given two strings s1 and s2, return their concatenation'),
        "tests": ['"foo", "bar"', '"foobar"']
    },
    {
        'task_id': "11",
        'prompt': mod_prompt('given a number n, return its square'),
        "tests": ["4", "16"]
    },
    {
        'task_id': "12",
        'prompt': mod_prompt('given a string s, return the number of characters in the string'),
        "tests": ['"hello"', "5"]
    },
    {
        'task_id': "13",
        'prompt': mod_prompt('given two numbers a and b, return the smaller number'),
        "tests": ["3 \n 7", "3"]
    },
    {
        'task_id': "14",
        'prompt': mod_prompt('given a string s, return True if all characters in the string are vowels, else False'),
        "tests": ['"aeiou"', "True"]
    },
    {
        'task_id': "15",
        'prompt': mod_prompt('given two numbers a and b, return the absolute difference between them'),
        "tests": ["7 \n 3", "4"]
    },
    {
        'task_id': "16",
        'prompt': mod_prompt('given a string s and a number n, return the string repeated n times'),
        "tests": ['"abc", 3', '"abcabcabc"']
    }
    ,{
      'task_id': "17",
      'prompt': mod_prompt('given a number n, return the Fibonacci sequence up to the nth term'),
      "tests": ["5", "[0, 1, 1, 2, 3]"]
  },
  {
      'task_id': "18",
      'prompt': mod_prompt('given a list of numbers, return the maximum number'),
      "tests": ["[3, 1, 4, 1, 5, 9]", "9"]
  },
  {
      'task_id': "19",
      'prompt': mod_prompt('given a string s, return True if it is a palindrome, else False'),
      "tests": ['"racecar"', "True"]
  },
  {
      'task_id': "20",
      'prompt': mod_prompt('given two numbers a and b, return their greatest common divisor'),
      "tests": ["8 \n 12", "4"]
  },
  {
      'task_id': "21",
      'prompt': mod_prompt('given a list of numbers, return the list sorted in ascending order'),
      "tests": ["[4, 2, 5, 1]", "[1, 2, 4, 5]"]
  },
  {
      'task_id': "22",
      'prompt': mod_prompt('given a number n, return True if it is a perfect square, else False'),
      "tests": ["16", "True"]
  },
  {
      'task_id': "23",
      'prompt': mod_prompt('given a string s, return the number of vowels in the string'),
      "tests": ['"hello"', "2"]
  },
  {
      'task_id': "24",
      'prompt': mod_prompt('given a list of numbers, return the sum of all numbers in the list'),
      "tests": ["[1, 2, 3, 4]", "10"]
  },
  {
      'task_id': "25",
      'prompt': mod_prompt('given a number n, return its binary representation as a string'),
      "tests": ["10", '"1010"']
  },
  {
      'task_id': "26",
      'prompt': mod_prompt('given two strings s1 and s2, return True if s1 is an anagram of s2, else False'),
      "tests": ['"listen", "silent"', "True"]
  },
  {
      'task_id': "27",
      'prompt': mod_prompt('given a number n, return the sum of digits in n'),
      "tests": ["1234", "10"]
  },
  {
      'task_id': "28",
      'prompt': mod_prompt('given a list of numbers, return True if all numbers are even, else False'),
      "tests": ["[2, 4, 6, 8]", "True"]
  },
  {
      'task_id': "29",
      'prompt': mod_prompt('given a string s, return the string in title case'),
      "tests": ['"hello world"', '"Hello World"']
  },
  {
      'task_id': "30",
      'prompt': mod_prompt('given two numbers a and b, return True if a is divisible by b, else False'),
      "tests": ["10 \n 2", "True"]
  }

]

os.environ["OPENAI_API_KEY"] =

from openai import OpenAI
results = []
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))



from google.colab import drive
drive.mount('/content/drive')

import sys
import os
import re
import subprocess
import tempfile
import ast
import functools as ft
import random as rd
import io
import contextlib
from typing import List, Tuple, Any

# -----------------------------------------------------------------------------
# 1. Save the Minipy boilerplate as minipy.py
# -----------------------------------------------------------------------------

minipy_boilerplate = """
import sys as y
av = y.argv
if len(av) > 1:
    v1 = av[1]
    try:
        v2 = eval(v1)
    except SyntaxError:
        pass
import os
import re
import functools as ft
import string as st
import copy as cp
import random as rd
import math as m
ri = rd.randint
rt = lambda seq: seq[ri(0, len(seq)-1)]
N = None
_i = __import__
_b = __builtins__
_B = dir(_b)
ab = abs
al = all
an = any
bn = bin
c = chr
cx = complex
d = dict
dr = dir
em = enumerate
e = eval
x = exec
b = lambda x: lambda y: eval(x)
fm = lambda x,y: map(b(x),y)
ff = lambda x,y: filter(b(x),y)
fr = ft.reduce
fl = float
gtat = getattr
hsat = hasattr
dlat = delattr
stat = setattr
hx = hex
i = input
n = lambda *args: eval(input(*args))
sr = ""
t = int
l = len
ls = list
ot = oct
o = open
f = lambda s: o(s).read()
p = print
r = range
rp = repr
rvr = reversed
rnd = round
srt = sorted
s = str
sm = sum
v = vars
z = zip
def rf(s): # regex finder
    index = s.index("!")
    regex = re.compile(s[:index])
    search = s[index + 1 :]
    if search[0] == "!":
        return regex.findall(search[1:])
    else:
        return regex.findall(eval(search))
q = chr(34)
k = "\\n"

def e(s):
    raise RuntimeError(s)
"""

with open("minipy.py", "w") as f_file:
    f_file.write(minipy_boilerplate)

# -----------------------------------------------------------------------------
# 2. Save the interpreter as interpreter.py
# -----------------------------------------------------------------------------

# This interpreter simply reads and executes the file passed as argument.
interpreter_code = """
from minipy import *
import sys
if len(sys.argv) < 2:
    raise ValueError("No code file provided.")
with open(sys.argv[1], "r") as file:
    code = file.read()
exec(code)
"""
with open("interpreter.py", "w") as f_file:
    f_file.write(interpreter_code)

print("Minipy and interpreter setup complete!")

# -----------------------------------------------------------------------------
# 3. Helper: Parse Test Input Arguments
# -----------------------------------------------------------------------------
def parse_test_input(arg_str: str):
    """
    Parses a test input string into proper Python values.
    - If the string is empty, returns None.
    - If the string contains newline characters (and no commas), splits on newlines.
    - Otherwise, tries to use ast.literal_eval to get numbers, tuples, etc.
    If literal_eval fails, returns the raw string.
    """
    arg_str = arg_str.strip()
    if not arg_str:
        return None
    if "\n" in arg_str and "," not in arg_str:
        parts = [x.strip() for x in arg_str.splitlines() if x.strip()]
        parsed_parts = []
        for part in parts:
            try:
                parsed_parts.append(ast.literal_eval(part))
            except Exception:
                parsed_parts.append(part)
        return tuple(parsed_parts)
    else:
        try:
            return ast.literal_eval(arg_str)
        except Exception:
            return arg_str

# -----------------------------------------------------------------------------
# 4. Execution & Testing Utilities
# -----------------------------------------------------------------------------
def execute_minipy_code(code: str, input_data: str = "") -> str:
    """
    Executes Minipy code using our interpreter and returns its output or error messages.
    """
    try:
        MINIPY_INTERPRETER_PATH = os.path.abspath("interpreter.py")
        if not os.path.isfile(MINIPY_INTERPRETER_PATH):
            return f"Error: Minipy interpreter not found at '{MINIPY_INTERPRETER_PATH}'."
        with tempfile.NamedTemporaryFile(mode="w+", suffix=".minipy", delete=False) as temp_minipy:
            temp_minipy_path = temp_minipy.name
            temp_minipy.write(code)
        try:
            result = subprocess.run(
                ['python3', MINIPY_INTERPRETER_PATH, temp_minipy_path],
                input=input_data,
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode != 0:
                return f"Error: {result.stderr.strip()}"
            return result.stdout.strip()
        finally:
            os.remove(temp_minipy_path)
    except subprocess.TimeoutExpired:
        return "Error: Execution timed out."
    except Exception as e:
        return f"Error during execution: {str(e)}"

def extract_function_name_and_convert(minipy_code: str) -> str:
    """
    Extracts the name of the first function defined either via a 'def' or a lambda assignment.
    """
    pattern_def = r"def\s+(\w+)\s*\("
    match = re.search(pattern_def, minipy_code)
    if match:
        return match.group(1)
    pattern_lambda = r"(\w+)\s*=\s*lambda"
    match = re.search(pattern_lambda, minipy_code)
    if match:
        return match.group(1)
    return ""

def extract_minipy_code(generated_content: str) -> str:
    """
    Extracts Minipy code from a code block.
    Accepts fences labeled with minipy, python, or no label.
    """
    code_pattern = r"```(?:minipy|python)?\s*\n([\s\S]*?)```"
    match = re.search(code_pattern, generated_content)
    if match:
        return match.group(1).strip()
    incomplete_pattern = r"```(?:minipy|python)?\s*\n([\s\S]*)"
    incomplete_match = re.search(incomplete_pattern, generated_content)
    if incomplete_match:
        return incomplete_match.group(1).strip()
    return generated_content.strip()

def test_minipy_function(minipy_code: str, func_name: str, args: str, input_data: str = "") -> str:
    """
    Executes the generated Minipy code using our interpreter.
    If a function is defined, appends a function call with the parsed test inputs.
    """
    parsed = parse_test_input(args)
    if parsed is None:
        args_str = ""
    elif isinstance(parsed, tuple):
        args_str = ', '.join(repr(x) for x in parsed)
    else:
        args_str = repr(parsed)

    if func_name:
        function_call = f"print({func_name}({args_str}))"
        combined_code = f"{minipy_code.strip()}\n\n{function_call}"
    else:
        combined_code = minipy_code.strip()
    return execute_minipy_code(combined_code, input_data)

def test_py_function(minipy_code: str, func_name: str, args: str, input_data: str = "") -> str:
    """
    Tests whether the extracted code is executable directly in Python.
    This function compiles and executes the code while capturing its output.
    If the code executes without errors, its output is returned.
    """
    parsed = parse_test_input(args)
    if parsed is None:
        args_str = ""
    elif isinstance(parsed, tuple):
        args_str = ', '.join(repr(x) for x in parsed)
    else:
        args_str = repr(parsed)

    if func_name:
        function_call = f"print({func_name}({args_str}))"
        combined_code = f"{minipy_code.strip()}\n\n{function_call}"
    else:
        combined_code = minipy_code.strip()

    out = io.StringIO()
    with contextlib.redirect_stdout(out):
        compiled_code = compile(combined_code, '<string>', 'exec')
        exec(compiled_code, {})
    return out.getvalue().strip()


file_path = "/content/drive/MyDrive/esolangs/minipy/minipyexamples.py"  # Update with the actual file path

with open(file_path, "r", encoding="utf-8") as file:
    file_content = file.read()


def mod_prompt(prompt):
    """
    Modifies the prompt to ask for a function written in Minipy.
    """
    modified_prompt = (
        f"Write a function in Minipy, an esoteric programming language. "
        f"The function should perform the following: {prompt}\n"
        f"Minipy is a shorthand for Python. Use all available shorthands. "
        f"Here is the Minipy documentation: '{minipy_boilerplate}'."
        f"Here are examples of Minipy Code: '{file_content}'."
    )
    return modified_prompt

# -----------------------------------------------------------------------------
# 5. Problems and Evaluation Loop
# -----------------------------------------------------------------------------
problems = [
    {
        'task_id': "1",
        'prompt': mod_prompt('print hello world'),
        "tests": ["", 'Hello world']
    },
    {
        'task_id': "2",
        'prompt': mod_prompt('given a number n input, return the nth factorial number'),
        "tests": ["5", "120"]
    },
    {
        'task_id': "3",
        'prompt': mod_prompt('given a number n, return "Even" if n is even, else "Odd"'),
        "tests": ["4", '"Even"']
    },
    {
        'task_id': "4",
        'prompt': mod_prompt('given two numbers a and b, return their sum'),
        "tests": ["2 \n 3", "5"]
    },
    {
        'task_id': "5",
        'prompt': mod_prompt('given a number n, return True if it is prime, else False'),
        "tests": ["11", "True"]
    },
    {
        'task_id': "6",
        'prompt': mod_prompt('given a string s, return the reversed string'),
        "tests": ["hello", '"olleh"']
    },
     {
        'task_id': "7",
        'prompt': mod_prompt('print "Hello, Pyth!"'),
        "tests": ["", '"Hello, Pyth!"']
    },
    {
        'task_id': "8",
        'prompt': mod_prompt('given two numbers a and b, return their product'),
        "tests": ["2 \n 3", "6"]
    },
    {
        'task_id': "9",
        'prompt': mod_prompt('given a number n, return True if it is positive, else False'),
        "tests": ["10", "True"]
    },
    {
        'task_id': "10",
        'prompt': mod_prompt('given two strings s1 and s2, return their concatenation'),
        "tests": ['"foo", "bar"', '"foobar"']
    },
    {
        'task_id': "11",
        'prompt': mod_prompt('given a number n, return its square'),
        "tests": ["4", "16"]
    },
    {
        'task_id': "12",
        'prompt': mod_prompt('given a string s, return the number of characters in the string'),
        "tests": ['"hello"', "5"]
    },
    {
        'task_id': "13",
        'prompt': mod_prompt('given two numbers a and b, return the smaller number'),
        "tests": ["3 \n 7", "3"]
    },
    {
        'task_id': "14",
        'prompt': mod_prompt('given a string s, return True if all characters in the string are vowels, else False'),
        "tests": ['"aeiou"', "True"]
    },
    {
        'task_id': "15",
        'prompt': mod_prompt('given two numbers a and b, return the absolute difference between them'),
        "tests": ["7 \n 3", "4"]
    },
    {
        'task_id': "16",
        'prompt': mod_prompt('given a string s and a number n, return the string repeated n times'),
        "tests": ['"abc", 3', '"abcabcabc"']
    }
    ,{
      'task_id': "17",
      'prompt': mod_prompt('given a number n, return the Fibonacci sequence up to the nth term'),
      "tests": ["5", "[0, 1, 1, 2, 3]"]
  },
  {
      'task_id': "18",
      'prompt': mod_prompt('given a list of numbers, return the maximum number'),
      "tests": ["[3, 1, 4, 1, 5, 9]", "9"]
  },
  {
      'task_id': "19",
      'prompt': mod_prompt('given a string s, return True if it is a palindrome, else False'),
      "tests": ['"racecar"', "True"]
  },
  {
      'task_id': "20",
      'prompt': mod_prompt('given two numbers a and b, return their greatest common divisor'),
      "tests": ["8 \n 12", "4"]
  },
  {
      'task_id': "21",
      'prompt': mod_prompt('given a list of numbers, return the list sorted in ascending order'),
      "tests": ["[4, 2, 5, 1]", "[1, 2, 4, 5]"]
  },
  {
      'task_id': "22",
      'prompt': mod_prompt('given a number n, return True if it is a perfect square, else False'),
      "tests": ["16", "True"]
  },
  {
      'task_id': "23",
      'prompt': mod_prompt('given a string s, return the number of vowels in the string'),
      "tests": ['"hello"', "2"]
  },
  {
      'task_id': "24",
      'prompt': mod_prompt('given a list of numbers, return the sum of all numbers in the list'),
      "tests": ["[1, 2, 3, 4]", "10"]
  },
  {
      'task_id': "25",
      'prompt': mod_prompt('given a number n, return its binary representation as a string'),
      "tests": ["10", '"1010"']
  },
  {
      'task_id': "26",
      'prompt': mod_prompt('given two strings s1 and s2, return True if s1 is an anagram of s2, else False'),
      "tests": ['"listen", "silent"', "True"]
  },
  {
      'task_id': "27",
      'prompt': mod_prompt('given a number n, return the sum of digits in n'),
      "tests": ["1234", "10"]
  },
  {
      'task_id': "28",
      'prompt': mod_prompt('given a list of numbers, return True if all numbers are even, else False'),
      "tests": ["[2, 4, 6, 8]", "True"]
  },
  {
      'task_id': "29",
      'prompt': mod_prompt('given a string s, return the string in title case'),
      "tests": ['"hello world"', '"Hello World"']
  },
  {
      'task_id': "30",
      'prompt': mod_prompt('given two numbers a and b, return True if a is divisible by b, else False'),
      "tests": ["10 \n 2", "True"]
  }

]


passed = 0
results = []


from openai import OpenAI
# Initialize results
results = []
os.environ["OPENAI_API_KEY"] =
# Initialize OpenAI client
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))


# We'll test only the first three problems for brevity.
for idx, problem in enumerate(problems, start=1):
    print(f"Evaluating Problem {idx}/{len(problems)}: {problem['task_id']}")
    try:
        response = client.chat.completions.create(
            model="gpt-4o",  # Replace with your actual model name
            messages=[
                {
                    "role": "system",
                    "content": (
                        f"You are an assistant that writes Minipy code. "
                        f"Minipy is a shorthand for Python. The following documentation is provided:\n\n{minipy_boilerplate}\n\n"
                        "Please use all shorthands where applicable."
                    ),
                },
                {
                    "role": "user",
                    "content": mod_prompt(problem['prompt']),
                }
            ],
            temperature=0.0,
            max_tokens=500
        )

        generated_content = response.choices[0].message.content.strip()
        print(f"Generated Minipy Code:\n{generated_content}\n")
        minipy_code_extracted = extract_minipy_code(generated_content)
        print(f"Extracted Minipy Code:\n{minipy_code_extracted}\n")

        func_name = extract_function_name_and_convert(minipy_code_extracted)
        if func_name:
            print(f"Detected function definition: {func_name}")
        else:
            print("No function definition detected; treating as a script.")

        output = test_minipy_function(minipy_code_extracted, func_name, problem['tests'][0])
        print(f"minipy Output: {output}\n")

        # Now test if the same code is executable directly by Python.
        python_executable = False
        try:
            py_output = test_py_function(minipy_code_extracted, func_name, problem['tests'][0])
            # If no exception is raised, we consider it executable.
            python_executable = True
        except Exception as e:
            python_executable = False

        expected = problem['tests'][1].strip('"').lower()
        test_pass = expected in output.lower()
        results.append({
            'problem': problem['task_id'],
            'pass': test_pass,
            'code': minipy_code_extracted,
            'output': output,
            'python_executable': python_executable
        })
        print("Pass:", test_pass, "Output type:", type(output))
        print("Executable via Python interpreter:", python_executable)

    except Exception as e:
        print(f"Error during API call: {e}")

print("\nEvaluation Results:")
for res in results:
    print(f"Problem {res['problem']}: {'PASS' if res['pass'] else 'FAIL'}")
    print(f"  Executable via Python interpreter: {res['python_executable']}")

# results of both passing with minipy interpreter and passing with minipy interpreter & not python.

passed = 0
nonexecut = 0
for result in results:
    print(f"Problem {result['problem']}:")
    print(f"Pass: {result['pass']}")
    print(f"Non executable via python interpretor: {result['python_executable']}")
    if result['pass'] == True:
      passed += 1
    if result['pass'] == True and result['python_executable'] == False:
      nonexecut += 1

print(f"Passed: {passed}/{len(results)}")
print(f"Passed + not executable by pthon: {nonexecut}/{len(results)}")